pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'your-registry.com'
        PROJECT_NAME = 'jobzee'
        AWS_REGION = 'us-west-2'
        EKS_CLUSTER_NAME = 'jobzee-cluster'
    }
    
    parameters {
        choice(
            name: 'DEPLOY_ENVIRONMENT',
            choices: ['dev', 'staging', 'production'],
            description: 'Select deployment environment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running tests'
        )
        booleanParam(
            name: 'SKIP_BUILD',
            defaultValue: false,
            description: 'Skip building images'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    // Set environment-specific variables
                    switch(params.DEPLOY_ENVIRONMENT) {
                        case 'dev':
                            env.NAMESPACE = 'jobzee-dev'
                            env.IMAGE_TAG = "${env.BUILD_NUMBER}-dev"
                            break
                        case 'staging':
                            env.NAMESPACE = 'jobzee-staging'
                            env.IMAGE_TAG = "${env.BUILD_NUMBER}-staging"
                            break
                        case 'production':
                            env.NAMESPACE = 'jobzee-prod'
                            env.IMAGE_TAG = "${env.BUILD_NUMBER}-prod"
                            break
                    }
                }
            }
        }
        
        stage('Install Dependencies') {
            parallel {
                stage('Frontend Dependencies') {
                    steps {
                        dir('multi-agent-frontend') {
                            sh 'npm ci'
                        }
                    }
                }
                stage('Backend Dependencies') {
                    steps {
                        dir('multi-agent-backend') {
                            sh 'go mod download'
                        }
                    }
                }
                stage('Agents Dependencies') {
                    steps {
                        dir('multi-agent-agents') {
                            sh 'pip install -r requirements.txt'
                        }
                    }
                }
            }
        }
        
        stage('Run Tests') {
            when {
                not { params.SKIP_TESTS }
            }
            parallel {
                stage('Frontend Tests') {
                    steps {
                        dir('multi-agent-frontend') {
                            sh 'npm run lint'
                            sh 'npm run type-check'
                            sh 'npm test'
                        }
                    }
                }
                stage('Backend Tests') {
                    steps {
                        dir('multi-agent-backend') {
                            sh 'go test ./... -v'
                            sh 'golangci-lint run'
                        }
                    }
                }
                stage('Agents Tests') {
                    steps {
                        dir('multi-agent-agents') {
                            sh 'pytest tests/ -v'
                            sh 'flake8 .'
                            sh 'mypy .'
                        }
                    }
                }
            }
        }
        
        stage('Build Images') {
            when {
                not { params.SKIP_BUILD }
            }
            parallel {
                stage('Build Frontend') {
                    steps {
                        dir('multi-agent-frontend') {
                            script {
                                docker.build("${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend:${IMAGE_TAG}")
                            }
                        }
                    }
                }
                stage('Build Backend') {
                    steps {
                        dir('multi-agent-backend') {
                            script {
                                docker.build("${DOCKER_REGISTRY}/${PROJECT_NAME}/backend:${IMAGE_TAG}")
                            }
                        }
                    }
                }
                stage('Build Agents') {
                    steps {
                        dir('multi-agent-agents') {
                            script {
                                docker.build("${DOCKER_REGISTRY}/${PROJECT_NAME}/agents:${IMAGE_TAG}")
                            }
                        }
                    }
                }
            }
        }
        
        stage('Push Images') {
            when {
                not { params.SKIP_BUILD }
            }
            steps {
                script {
                    // Login to Docker registry
                    withCredentials([usernamePassword(credentialsId: 'docker-registry', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh "echo ${DOCKER_PASS} | docker login ${DOCKER_REGISTRY} -u ${DOCKER_USER} --password-stdin"
                    }
                    
                    // Push images
                    sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend:${IMAGE_TAG}"
                    sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/backend:${IMAGE_TAG}"
                    sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/agents:${IMAGE_TAG}"
                    
                    // Tag as latest for dev environment
                    if (params.DEPLOY_ENVIRONMENT == 'dev') {
                        sh "docker tag ${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend:${IMAGE_TAG} ${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend:latest"
                        sh "docker tag ${DOCKER_REGISTRY}/${PROJECT_NAME}/backend:${IMAGE_TAG} ${DOCKER_REGISTRY}/${PROJECT_NAME}/backend:latest"
                        sh "docker tag ${DOCKER_REGISTRY}/${PROJECT_NAME}/agents:${IMAGE_TAG} ${DOCKER_REGISTRY}/${PROJECT_NAME}/agents:latest"
                        sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend:latest"
                        sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/backend:latest"
                        sh "docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}/agents:latest"
                    }
                }
            }
        }
        
        stage('Generate Protobuf') {
            steps {
                dir('multi-agent-protos') {
                    sh 'make generate-all'
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    // Configure kubectl for EKS
                    withCredentials([string(credentialsId: 'aws-access-key', variable: 'AWS_ACCESS_KEY_ID'), string(credentialsId: 'aws-secret-key', variable: 'AWS_SECRET_ACCESS_KEY')]) {
                        sh """
                            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                        """
                    }
                    
                    // Create namespace if it doesn't exist
                    sh "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
                    
                    // Deploy using Helm
                    dir('multi-agent-infra/kubernetes/helm') {
                        // Deploy backend
                        sh """
                            helm upgrade --install backend-${params.DEPLOY_ENVIRONMENT} ./backend \
                                --namespace ${NAMESPACE} \
                                --set image.tag=${IMAGE_TAG} \
                                --set image.repository=${DOCKER_REGISTRY}/${PROJECT_NAME}/backend \
                                --set database.host=postgres-${params.DEPLOY_ENVIRONMENT} \
                                --set redis.host=redis-${params.DEPLOY_ENVIRONMENT} \
                                --set kafka.bootstrapServers=kafka-${params.DEPLOY_ENVIRONMENT}:9092
                        """
                        
                        // Deploy frontend
                        sh """
                            helm upgrade --install frontend-${params.DEPLOY_ENVIRONMENT} ./frontend \
                                --namespace ${NAMESPACE} \
                                --set image.tag=${IMAGE_TAG} \
                                --set image.repository=${DOCKER_REGISTRY}/${PROJECT_NAME}/frontend
                        """
                        
                        // Deploy agents
                        sh """
                            helm upgrade --install agents-${params.DEPLOY_ENVIRONMENT} ./agents \
                                --namespace ${NAMESPACE} \
                                --set image.tag=${IMAGE_TAG} \
                                --set image.repository=${DOCKER_REGISTRY}/${PROJECT_NAME}/agents
                        """
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    // Wait for deployments to be ready
                    sh "kubectl wait --for=condition=available --timeout=300s deployment/backend-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}"
                    sh "kubectl wait --for=condition=available --timeout=300s deployment/frontend-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}"
                    sh "kubectl wait --for=condition=available --timeout=300s deployment/agents-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}"
                    
                    // Run health checks
                    sh "kubectl get pods -n ${NAMESPACE}"
                    sh "kubectl get services -n ${NAMESPACE}"
                }
            }
        }
        
        stage('Run Integration Tests') {
            when {
                not { params.SKIP_TESTS }
            }
            steps {
                script {
                    // Run integration tests against deployed environment
                    dir('tests/integration') {
                        sh """
                            export API_URL=http://backend-${params.DEPLOY_ENVIRONMENT}.${NAMESPACE}.svc.cluster.local:8080
                            pytest -v --env=${params.DEPLOY_ENVIRONMENT}
                        """
                    }
                }
            }
        }
    }
    
    post {
        always {
            // Cleanup
            sh 'docker system prune -f'
            
            // Archive test results
            archiveArtifacts artifacts: '**/test-results/**/*', allowEmptyArchive: true
            archiveArtifacts artifacts: '**/coverage/**/*', allowEmptyArchive: true
            
            // Publish test results
            publishTestResults testResultsPattern: '**/test-results/**/*.xml'
        }
        
        success {
            script {
                // Send success notification
                if (params.DEPLOY_ENVIRONMENT == 'production') {
                    emailext (
                        subject: "Deployment Successful - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: "Production deployment completed successfully.\n\nBuild: ${env.BUILD_URL}\nEnvironment: ${params.DEPLOY_ENVIRONMENT}\nImage Tag: ${env.IMAGE_TAG}",
                        to: 'team@jobzee.com'
                    )
                }
            }
        }
        
        failure {
            script {
                // Send failure notification
                emailext (
                    subject: "Deployment Failed - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: "Deployment failed.\n\nBuild: ${env.BUILD_URL}\nEnvironment: ${params.DEPLOY_ENVIRONMENT}\nConsole Log: ${env.BUILD_URL}console",
                    to: 'team@jobzee.com'
                )
                
                // Rollback on production failure
                if (params.DEPLOY_ENVIRONMENT == 'production') {
                    sh """
                        aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                        kubectl rollout undo deployment/backend-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}
                        kubectl rollout undo deployment/frontend-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}
                        kubectl rollout undo deployment/agents-${params.DEPLOY_ENVIRONMENT} -n ${NAMESPACE}
                    """
                }
            }
        }
    }
} 